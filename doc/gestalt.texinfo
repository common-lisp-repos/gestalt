\input texinfo   @c -*-texinfo-*-
@c %**start of header
@setfilename gestalt.info
@settitle Gestalt - A comprehensive Common Lisp Web Framework

@set VERSION 0.1
@set DATE November 2009

@c Version and Contact Info
@set MAINTAINERSITE @uref{http://common-lisp.net/project/gestalt, maintainers webpage}
@set AUTHOR Mariano Montone
@set MAINTAINER Mariano Montone
@set MAINTAINEREMAIL @email{marianomontone at gmail dot com}
@set MAINTAINERCONTACT @uref{mailto:marianomontone at gmail dot com,contact the maintainer}
@c %**end of header

@ignore
@ifinfo
@format
START-INFO-DIR-ENTRY
* Gestalt: (gestalt.info). A comprehensive Common Lisp Web framework.
END-INFO-DIR-ENTRY
@end format
@end ifinfo
@end ignore

@c Subheadings inside a table.
@macro tsubheading{text}
@ifinfo
@subsubheading \text\
@end ifinfo
@ifnotinfo
@item @b{\text\}
@end ifnotinfo
@end macro

@copying

This manual is for Gestalt Web Framework version @value{VERSION}.

Copyright @copyright{} 2009, 2010 Mariano Montone

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, with the Front-Cover texts being ``A GNU Manual,''
and with the Back-Cover Texts as in (a) below.  A copy of the license
is included in the section entitled ``GNU Free Documentation License.''

(a) The FSF's Back-Cover Text is: ``You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF supports it in
developing GNU and promoting software freedom.''

This document is part of a collection distributed under the GNU Free
Documentation License.  If you want to distribute this document
separately from the collection, you can do so by adding a copy of the
license to the document, as described in section 6 of the license.
@end quotation
@end copying

@titlepage
@title Gestalt
@subtitle A comprehensive Common Lisp Web Framework
@subtitle Release @value{VERSION}
@author by Mariano Montone

@c Output the table of contents at the beginning.
@contents

@c The following two commands start the copyright page.
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@ifnottex
@node Top
@top Gestalt - A comprehensive Common Lisp Web Framework

This is Gestalt Common Lisp Web Framework documentation

@end ifnottex

@menu
* Introduction::                What is Gestalt?
* Web application programming:: What does Web application programming consists of?
* Programming with Gestalt::    How does Web application programming feel like with Gestalt?
* Third-party libraries::       Gestalt's third-party libraries
* Standard applications::       Gestalt's resources for programming standard applications
* Tools::                       Tools that help with Gestalt applications development
* System reference::            System reference
* References::                  Related work
* Appendix::                    Appendix with references
* Index::                       Complete index.

@detailmenu
 --- The Detailed Node Listing ---

Introduction

* Summary::                     A brief summary of what Gestalt is
* Installation::                How to install Gestalt
* Feedback::                    Bug reports, ideas, patches etc.
* Conventions::                 Type-setting conventions in the manual

Web application programming

* Web application programming overview::  A brief summary of Web application programming
* Problems::                              The problems of Web application programming
* MVC in the Web::                        The Model-View-Controller in the Web

Programming with Gestalt

* Gestalt programming overview::          A brief summary of Web application programming with Gestalt
* MVC in Gestalt::                        How Gestalt approaches the MVC architecture
* The model::                             The Web application bussiness objects in Gestalt
* Model overview::                        An overview of what's the model like in Gestalt
* Why an object database?::               An explanation of why we stick to an object database
* Defining model objects::                How to define Gestalt model objects
* Objects validation::                    How model validation is done in Gestalt
* Consistent objects::                    What consistent objects are.
* Objects that require arguments::        How to define objects that require arguments
* The Elephant object database::          An overview of the Elephant object database
* The controller::                        The Web application controller in Gestalt
* Controller overview::                            The application controller in Gestalt overview
* Programming with components::                    How programming with components feels like.
* Application composition::     How to embed components inside other
* Call and answer semantics::   How we control the application flow?
* Component wrappers::          What are component wrappers
* Continuations::                                  What continuations are
* Continuations and web applications programming:: How are continuations used in web applications development
* Continuations and components::                   How are continuations and components related
* Model objects validation::                       How the controller deals with model objects validation errors
* View updates::                                   How the view gets updated
* View update overview::                           An overview of how the view gets updated
* Dataflow extensions::                            Summary of the dataflow programming extensions in Gestalt
* Dataflow and memory management::                              A brief description on how the memory in managed under dataflow
* The dynamic environment::                        Section about the dyanmic environment and what we can do with it
* Component threads and database transactions::    Component threads and database transactions overview
* Context Oriented Programming::                   Context Oriented Programming overview
* Layered components::                             Layered components overview
* The view::                   The Web application view in Gestalt
* View overview::              An overview of how the view is approached in Gestalt
* Defining a template::        The Gestalt template system overview
* Template assignation::       How templates get assigned to components
* Template elements::          Template elements
* Templates and scope::        Scope and template definitions
* Template combinations::      How templates can be combined
* Custom templates::           How to define your own class of templates
* Built-in templates classes:: Short reference of the already defined template classes

Third-party libraries
* First-class URLs::       Library that provides first-class URLs management
* Consistent objects::     consistent-object library reference
* Dataflow::               Dataflow library reference
* Utilities::              Utilities library (copying objects, doubly-linked lists, etc)

Standard applications

* Application login::         How to program the application login?
* Access control::            How to do permission checking
* Standard widgets::          The standard widgets
* Objects meta editors::      Generating objects editors reflectively

Tools

* Configuration::             How to configure a Gestalt application
* Debugging::                 How to debug Gestalt applications
* Inspector::             The web inspector
* Profiling::                 How to profile Gestalt applications
* Deployment::                How to deploy a Gestalt application

System References

References

Appendix

* System reference::                      Reference of system definitions

@end detailmenu
@end menu

@node Introduction
@chapter Introduction
Gestalt is yet another Common Lisp Web framework. Its purpose is to both try to make simple things simple and investigate new ideas in Web development.

  You can get a copy and this manual at @url{http://common-lisp.net/project/gestalt}

@menu
* Summary::                     A brief summary of what Gestalt is
* Installation::                How to install Gestalt
* Feedback::                    Bug reports, ideas, patches etc.
* Conventions::                 Type-setting conventions in the manual
@end menu

@node Summary
@section Summary
@cindex summary

This is Gestalt summary...

@node Installation
@section Installation
@cindex installation

To install gestalt, start a Common Lisp session and type the following:

@example
CL-USER> (require :asdf-install)
CL-USER> (asdf-install:asdf-install 'gestalt)
@end example

@node Feedback
@section Feedback
@cindex feedback

Mail marianomontone at gmail dot com with feedback

@node Conventions
@section Conventions
@cindex conventions

Hear are some coding conventions we'd like to follow:

@itemize

@bullet{We @emph{do} believe in documentation. Document your dynamic variables, functions, macros and classes. Besides, provide a documentation from a wider perspective. Provide diagrams and arquitecture documentation; examples and tutorials, too. Consider using an automatic documentation generator (see the bitacora package in the dependencies).}

@bullet{We don't want functions to be shorter than the should nor longer than they should. There is no "every function should have at most ten lines of code" rule. We think that coding is like literature to a great extent. So you should strive for beauty and clarity. Again, that your code is object oriented doesn't imply that your methods will ideally have two lines of code and dispatch to somewhere else; that is not always good at all. It may be good from an object oriented point of view, but it is too low level. We want to think in terms of languages, that is higher level,  instead of objects sending messages.}

@bullet{Use destructuring-bind or let or a pattern-matching library instead of car, cdr, cadr, and the like to obtain more readable code.}

@bullet{Use widely known Common Lisp coding guidelines: @url{http://web.archive.org/web/20050305123711/www.lisp.org/table/style.htm}}

@end itemize

@node Web application programming
@chapter Web application programming
@cindex web programming

Web application programming is like this...

@menu
* Web application programming overview::  A brief summary of Web application programming
* Problems::                              The problems of Web application programming
* MVC in the Web::                        The Model-View-Controller in the Web
@end menu

@node Web application programming overview
@section Web application programming overview

Web application programming is like this

@node Problems
@section Problems
@cindex web programming, problems of

The problems with Web application programming are these...

@node MVC in the Web
@section MVC in the Web
@cindex mvc

The MVC in the Web is like this...

@node Programming with Gestalt
@chapter Programming with Gestalt

Web application programming with Gestalt is like that...

@menu
* Gestalt programming overview::          A brief summary of Web application programming with Gestalt
* MVC in Gestalt::                        How Gestalt approaches the MVC architecture
* The model::                             The Web application bussiness objects in Gestalt
* The controller::                        The Web application controller in Gestalt
* The view::                              The Web application view in Gestalt
@end menu

@node Gestalt programming overview
@section Gestalt programming overview
@cindex gestalt, programming in
@cindex gestalt, overview

   Gestalt applications follow a MVC architecture. At the model layer, the framework is designed to work with an optimistic object database; that's because implicit saving of objects and long transactions are needed by the rest of the parts of the framework.
   
   At the controller level, we use a component based approach, a lot like the @url{http://seaside.st} Seaside framework; dataflow semantics for view updating.
   
   Finally, at the view level, we use a flexible and conveniente template engine and a set of widgets.

@node MVC in Gestalt
@section MVC in Gestalt
@cindex mvc

MVC in Gestalt is like this...

@node The model
@section The model

@menu
* Model overview::                 An overview of what's the model like in Gestalt
* Why an object database?::        An explanation of why we stick to an object database
* Defining model objects::         How to define Gestalt model objects
* Objects validation::             How model validation is done in Gestalt
* Consistent objects::             What consistent objects are.
* Objects that require arguments:: How to define objects that require arguments
* The Elephant object database::   An overview of the Elephant object 
@end menu

@node Model overview
@subsection Model overview
@cindex model

The model in a Gestalt application is based on an object database...

@node Why an object database?
@subsection Why an object database?
@cindex object database

    We persist objects in an object database because, on the one hand, our framework architecture relies on being able to store objects implicitly; that means, it is important for composability not to do explicit call to a save method on objects. Object database provide just this; they let us save objects implicitly just adding them to some root object. This let's us preserve composability.

    On the other hand, we need optimistic transactions. This is not a unique object database feature, but available RDBMs do not provide this in general, and the object database we are using does.

@node Defining model objects
@subsection Defining model objects

@node Objects validation
@subsection Objects validation
@cindex validation

@example
(defmethod validate ((person person))
  (check (and (stringp (name person))
	      (> (length (name person)) 0)))
  (check (and (stringp (lastname person))
	      (> (length (lastname person)) 0))))
@end example

@node Consistent objects
@subsection Consistent objects
@cindex consistent objects

@example
(defclass person ()
  ((name :initarg :name
	 :accessor name
	 :initform "")
   (lastname :initarg :lastname
	     :accessor lastname
	     :initform ""))
  (:metaclass consistent-object-class)
  (:documentation "A person"))

(defmethod validate ((person person))
  (ensure (and (stringp (name person))
	       (> (length (name person)) 0))
	  "Provide a name for ~A" person)
  (ensure (and (stringp (lastname person))
	       (> (length (lastname person)) 0))
	  "Provide a lastname for ~A" person))
  
(test consistent-object-test
      ;; The following fails:
      (signals consistency-error
	       (make-instance 'person))
      ;; The following fails:
      (signals consistency-error
	(let (person)
	  (suspending-consistency-for (person)
	    (setf person (make-instance 'person))
	    (setf (name person) "Mariano")
	    person)))

      ;; The following fails:
      (signals consistency-error
	       (let ((person (make-instance 'person)))
		 (setf (name person) "Mariano")
		 (setf (lastname person) "Montone")))

      ;; The following works:
      (finishes
	(let (person)
	  (suspending-consistency-for (person)
	    (setf person (make-instance 'person))
	    (setf (name person) "Mariano")
	    (setf (lastname person) "Montone")
	    person)))
      
      ;; Test the result is correct:
      (let (person)
	(let ((p (suspending-consistency-for (person)
		   (setf person (make-instance 'person))
		   (setf (name person) "Mariano")
		   (setf (lastname person) "Montone")
		   person)))
	  (is (name p) "Mariano")
	  (is (lastname p) "Montone"))))
@end example

@node Objects that require arguments
@subsection Objects that require arguments
@cindex required arguments

@example
(defclass person ()
  ((name :initarg :name :required t)
   (lastname :initarg :lastname :required t :error-msg "Please give me a lastname!!")
   (phone :initarg :phone :initform "" :required nil)
   (address :initarg :address :initform ""))
  (:metaclass required-slots-class)
  (:documentation "The class definition to test required slots"))

(defmethod print-object ((person person) stream)
  (print-unreadable-object (person stream :type t :identity t)
    (format stream "name: ~A lastname: ~A phone: ~A address: ~A"
	    (slot-value person 'name)
	    (slot-value person 'lastname)
	    (slot-value person 'phone)
	    (slot-value person 'address))))

(test required-slots-class-test
  (signals required-slot-error (make-instance 'person))
  (signals required-slot-error (make-instance 'person :name "Mariano"))
  (signals required-slot-error (make-instance 'person :lastname "Montone"))
  (finishes (make-instance 'person :name "Mariano" :lastname "Montone"))
  (signals required-slot-error (make-instance 'person :address "Mi casa")))
@end example

@node The Elephant object database
@subsection The Elephant object database
@cindex elephant database
@cindex object database

@node The controller
@section The controller
@cindex controller

@menu
* Controller overview::                            The application controller in Gestalt overview
* Programming with components::                    How programming with components feels like.
* Continuations::                                  What continuations are
* Model objects validation::                       How the controller deals with model objects validation errors
* View updates::                                   How the view gets updated
* Dataflow extensions::                            Summary of the dataflow programming extensions in Gestalt
* The dynamic environment::                        Section about the dynamic environment and what we can do with it
@end menu

@node Controller overview
@subsection Controller overview
@cindex controller

@node Programming with components
@subsection Programming with components
@cindex components
@menu
* Application composition::     How to embed components inside other
* Call and answer semantics::   How we control the application flow?
* Component wrappers::          What are component wrappers
* Application navigation and bookmarking::  Application navigation and bookmarking
* URL format::                  How the url is formatted
@end menu

@node Call and answer semantics
@subsubsection Call and answer semantics
@cindex call
@cindex answer

When an active component calls another, it loses its control and passes it to the called component. The called component becomes the active one.

If an unactive component answers, then an error is raised (although proper restarts are available).

If an unactive component calls another, then an error is raised (although proper restarts are available).

If a child component calls another, then it loses focus, and the called one gains control.

If a child component answers an object, then it desappears from the screen. The parent can set a callback on it to intercept the child component answer. Child components multiply the flow of control. Continuation passing doesn't hold anymore in their presence. Example:

@example
(defmethod initialize :after ((component my-component) &rest initargs)
  (declare (ignore initargs))
  (add-child (component first-child)
   (format t "This is the first flow of control")
   (let ((answer (call (make-instance 'my-child-component)))) ;; This embeds and sets the child component
     ;; The answer
     (format t "The first child component answered ~A" answer)))
  (add-child (component second-child)
   (format t "This is the second flow of control")
   (let ((answer (call (make-instance 'my-child-component)))) ;; This embeds and sets the child component
     ;; The answer
     (format t "The second child component answered ~A" answer))))
@end example

@node Application composition
@subsubsection Application composition
@cindex composition

Wow!! add-child doen't take a component, it is a macro and takes a block of code (that corresponds to the concurrent control flow). It is the fork equivalent!! Great...

Sketchy implementation:

@example
(defmacro add-child (component slot &rest body)
  (once-only (component)
	     `(setf (slot-value ,slot ,component)
		    (make-instance 'child-component-handler
				   :name (symbol-name ,slot)
				   :parent ,component
				   :go (lambda (self)
					 ,@@body)))))

(defmethod call ((self child-component-handler) other-component &rest args)
  "call redefinition for child components calling"
  ;; set which is the child component (we need that, the template system needs to know which are the child components, for example)
  (setf (component self) component)
  ;; invoque the original call operation
  (prim-call self comp args))

(defmacro simple-add-child (component slot child-component)
  "Adds a child-component without 'threading code' complications"
  `(add-child ,component ,slot
	      (call ,child-component)))
@end example              

child-component-handler may be designed as a subclass of task as it has a :go lambda.
It is different from a task because we need to redefine the call method on it in order to indicate
which is the new child component in the slot.

tasks are components with a :go lambda.

(defclass task (component)
  ((go :initarg :go :accessor go)))

Note: task components or variations of them may act as component-wrappers and/or child-component-handlers. Think about that.

We can extend this idea of child "components" and consider "building the whole component tree from lambdas"

About "component tree from lambdas":
-------------------------------

We can build the component tree from lambdas. The semantics of some of the operations depends on what kind of component we are building.

For example, to declare the main component, we could have:

@example
(defapplication my-application ()
  ())

(defvar *application* nil "The running application")
@end example

;; We use defmethod/cc. We need continuations for component calling, and dynamic environment restoring (contextl) so that dynamic variables and
;; other structures continue to make sense in presence of continuations.

@example
(defmethod/cc start-application :around ((app application))
   (let
       ((*application* app))
     (dflet ;; dynamic functions binding
         ((call (component)  ; the semantics of the call operation depends on the context (in this case we are setting the root component)
	      (set-root-component *application* component)))
	 (call-next-method))))

(defmethod/cc start-application ((app my-application))
  ;; now, this is an example of how we can specify the root component of our application
  (loop while t
       do (let ((user (call (make-instance 'login-component))))
	    (set-logged-user user)
	    (call (make-instance 'main-component))
	    (unlog-user))))
@end example            

Other example, is the semantics of call when adding child components.

@node Component wrappers
@subsubsection Component wrappers
@cindex wrappers

Implement component-wrappers (should be the equivalent of :after :before :around and other method combinations for methods).

component-wrappers should alter the behaviour of a component (for example, its rendering), but should remain transparent to some machinery (for example, the templating engine assignment policy should be independent of component-wrappers. component-wrappers are invisible to the template-engine).

Use case:

We can use component-wrappers to build complex objects editors. In general, an object editor should not contain an accept and cancel button, because that depends on the context. So, the following is incorrect:

@example
(defcomponent person-editor ()
  ((name :type :input :model (name model))
   (lastname :type :input :model (lastname model))
   (accept :type :button :on-click (accept-edition self))      <-- The accept button should not belong to the editor
   (cancel :type :button :on-click (cancel-edition self))))    <-- The cancel button should not belong to the editor
@end example   

The problem with this design is that it is difficult to build more complex editors from existent ones.

@example
(defcomponent artist-editor ()
  ((artistic-name :type :input :model (artistic-name model))
   (art :type :input :model (art model))
   (accept :type :button :on-click (accept-edition self))      <-- The accept button should not belong to the editor
   (cancel :type :button :on-click (cancel-edition self))))    <-- The cancel button should not belong to the editor
@end example

The problem is that person-editor and artist-editor are not incompatible by design, but we are adding the accept and cancel button twice.

A possible solution is to use component-wrappers:

@example
(defcomponent-wrapper editor-wrapper ()
  (:render (component wrapper)
	   (call-next-method)    ; We render the component
	   ; We render the accept and cancel buttons once.
	   (accept :type :button :on-click (accept-edition self))
	   (cancel :type :button :on-click (cancel-edition self))))

(defmethod call ((wrapper editor-wrapper))
  ; We wrap the editor call
  (with-transaction
      (call (component wrapper))))
@end example      

And with transaction should expand to something similar to:

@example
(unwind-protect
     (tagbody edition-block
	(restart-case (progn
			(begin-transaction)
			(call (component wrapper))
			(commit-stm-transaction))
	  (retry-edition ()
	    :report (lambda (stream)
		      (format stream "Restart the edition"))
	    ;; This is all. It's responsibility of the piece of code that
	    ;; throws errors to provide other restarts, such as :continue, for example.
	    (rollback-transaction)
	    (go edition-block))
	  (abort-edition ()
	    :report (lambda (stream)
		      (format stream "Abort the edition"))
	    (rollback-transaction))))
  (when (transaction-active)
    (rollback-transaction)))
@end example

THIS IS WHY WE NEED TO ADAPT DYNAMIC LANGUAGE CONSTRUCTS TO COMPONENT CHAINING!!

Finally, under this scheme, the editor component should commit anything on accept, and raise a signal (versioning-error, etc) on error.

@node Application navigation and bookmarking
@subsubsection Application navigation and bookmarking
@cindex navigation
@cindex bookmarking
@cindex bookmarks
@cindex url

The bookmarking problem is difficult to solve in the context of a complex Web application. In particular, it is not clear how to obtain a particular state of the application from a simple bookmarking string. Besides, there are some states of the application that cannot and should not be reached by bookmarking. That's the case of a user session navigation (content that is available to a logged user only) or a commercial transaction, for example. So, first, we must identify the parts of the application that are reachable by bookmarking. Second, we must provide a framework that allows us to do that as simply and naturally as possible.

One approach to solve the problem, would be to map the application as a state transition machine, identify the navigational paths, and apply a tag to each one of them. But we've already seen that determine each of the states is not desirable in complex Web applications. So we'd better find a better approach.

Discarding the state machine, there are at least two more possibilities to solve the problem:

One would be to register the components calling chain. The advantages are: we can repeat the navigation chain to reach any state. The disadvantages are: the chain of components gets large depending of how much time the user has been navigating. That is to say, how many transitions the user caused. On the other hand, there's room for a lot of unnecesary applications transitions; a same state could have been reached with less transitions. This is because this solution is not mapping a multiple input (components transition) to a unique output (a declarative application state specification). [See the next section for a generalized explanation of this problem].

The other option is to register pertinent navigation layers and component states to reach the desired state. Bookmarks have a declarative taste, like this.

@example
bookmark = layers=layer1:layer2+collection-navigator-1:offset=22:segment=22... etc
@end example

Each component should define how to be restored given some parameters. Some components may be uninteresting to restore, once more, depending on the context.

Bookmarking configuration: we can have three ways of configuring a component.
@enumerate
From the component itself (subclasses, mixins, class definition).
@example
(defcomponent collection-navigator ()

  (:bookmarking (offset :accessor bm-offset) ;; bm-offset is used to extract the offset in bookmarking format. (setf bm-offset) is used to set the component offset from a bookmarking parameter)
		(segment :accessor bm-segment))
  (:bookmark :all))
@end example  

From the outside.
@example
(with (make-instance 'collection-navigator :on my-collection)
      (disable-bookmarking-of 'segment it)
      (call it))
@end example      

From the outside, dynamically. It may be useful if we don't want to bookmark certain embedded subcomponent nor any of its components.
@example
(with (make-instance 'my-complex-component)
      (disabling-bookmarking
       (call it)))
@end example       
@end enumerate

@node URL format
@subsubsection URL format
@cindex url

Syntax:
@example
url ::= host/path?[session]&[continuation]&[bookmark]
session ::= _s=session-id
continuation ::= _c=continuation-id
@end example

Arguments and values:
@example
@itemize
session-id -- The session id
continuation-id -- The continuation id
bookmark -- @ref{Application navigation and bookmarking}
@end itemize
@end example

Semantics:

If the session-id is present, then: if the continuation-id is present, the continuation is executed. If the continuation is not in the server in that session (it may have expired or have been stored as part of a bookmark), then there's an attempt to restore the application state from the bookmark parameters. If that cannot be done, then the request fails.

If the continuation-id is present, but the session-id is not, then there's an attempt to restore the application from the bookmarks.

@node Continuations
@subsection Continuations
@cindex continuation

@menu
* Continuations and web applications programming:: How are continuations used in web applications development
* Continuations and components::                   How are continuations and components related
@end menu

@node Continuations and web applications programming
@subsubsection Continuations and web applications programming

@node Continuations and components
@subsubsection Continuations and components

@node Model objects validation
@subsection Model objects validation
@cindex validation

@node View updates
@subsection View updates
@cindex update, view

@menu
* View update overview::                           An overview of how the view gets updated
@end menu

@node View update overview
@subsubsection View update overview

@node Dataflow extensions
@subsection Dataflow extensions
@cindex dataflow

@menu
* Dataflow and memory management::                              A brief description on how the memory in managed under dataflow
@end menu

@node Dataflow and memory management
@subsubsection Dataflow and memory management
@cindex memory management, dataflow and

I have thought dataflow extensions to be used with a garbage collector. That means, you should use weak-references most of the time, and strong-referencing and explicit memory deallocation in exceptional cases. For example, you may want to respond to some event in some object, but you may not be interested in that object itself. So you want to reference the object strongly because it would be gone otherwise. REVISE THIS PREVIOUS SENTECES.

@node The dynamic environment
@subsection The dynamic environment
@cindex environment
@cindex dynamic environment

@menu
* Component threads::                              What component threads are
* Example - Programming a login::                  A login example
* Component threads and database transactions::    Component threads and database transactions overview
* Context Oriented Programming::                   Context Oriented Programming overview
* Layered components::                             Layered components overview
@end menu

@node Component threads
@subsubsection Component threads
@cindex threads, component

Child threads are aborted if the parent is aborted. For example, if the user hits the logout button of the root component, all of the child components are aborted before aborting the root component.

So, for example:

@example
(defapplication my-application ()
  ())

(defmethod/cc start-application ((app my-application))
  ;; now, this is an example of how we can specify the root component of our application
  (loop while t
       do (let ((user (call (make-instance 'login-component))))
	    (set-logged-user user)
	    (call (make-instance 'main-component)) ; **
	    (unlog-user))))
@end example            

When the user hits the logout button of the main-component, the main-component child threads are aborted before proceeding. Note that aborting a child component may lead to some behaviour. For example, if the child component is an editor that is configured to ask for cancellation in case the user leaves the component. Then, trying to logout, will raise the cancelling exception and a dialog box asking for cancellation will appear; the user will not be able to logout without asking. Now, that's ok, but it would be interesting to think how we can control that. For example, we may want the editor to avoid asking the question in case we hit the logout button, but ask it otherwise. It's not clear how to achieve that with a "threading" semantics. Possible solution??: the logout button activates a layer. That layer should deactivate the abort-condition catch up that shows the dialog, and provide some that just proceeds with the editor abortion. Not trivial anyway...but interesting.

Not that the components threads semantics is preemtive; the parent component may abort nested components.

Implementation thought: we may implement dynamic environments manual setting using ContextL dynamic-environments manipulation library. Then, each component would hold its own dynamic layer (or environment). The user should be able to control whether he wants to restore some dynamic environments or not. In the logout case, we don't want to restore the aborted component (editor) dynamic environment; we want to treat signaled conditions differently (for example, avoiding a question dialog, and proceeding instead). If the user leaves, or hits cancel, then we *do* want to restore the components dynamic environment.

Sketch:

Suppose we have A as the parent of B. B calls C for performing some operation.
@example
(defmethod initialize-instance :after ((comp A) &rest initargs)
  (add-child comp
	...     
   (call comp 'B)
     ...
   ))

;; add-child should get translated to the following:
(let ((env (dynamic-environment comp)))
  (with-dynamic-environment env ;; the parent component dynamic-environment
    (dynamic-wind     ;; This *should* compose the local environment with the above one
     ...
     (proceed
      (let ((child (make-instance 'B)))
	(setf (environment child) (capture-dynamic-environment))
	(effectively-add-child child)))
     ...)))

(defaction accept-action ((comp B))
  ...
  (call 'C)
  ...)

; should be translated to something like:
(let ((env (dynamic-environment comp)))
  (with-dynamic-environment env ;; the parent component dynamic-environment
    (dynamic-wind     ;; This *must* compose the local environment with the above one
     ...
     (proceed
      (let ((calle (make-instance 'B)))
	(setf (environment calle) (capture-dynamic-environment))
	(effective-call calle)))
     ...)))

;; Note:
;; First: the code before and after the call (...) is part of the dynamic winding (altough if we have continuations "there's no after code").
;; Second: with-dynamic-environment pushes the reevaluated thunks to the stack so we get an augmented dynamic environment when we call capture-dynamic-environment. So, now we have component threads dynamic-environments. So, for example, component threads dynamic variables can be accesed like this:

(defdynamic my-var 33)
(defdynamic parent-var 22)

;; Luego podemos acceder esa variable con (dynamic my-var) en el scope generado a través de la inyección de environments en los componentes:

(defmethod initialize-instance :after ((comp A))
  (add-child comp
    (dynamic-let
       ((parent-var 45))
         (call 'B))))

(defaction accept-action ((comp B))
  (dynamic-let
    ((my-var 55))
      (call 'C)))

(defmethod initialize-instance :after ()
    (print (dynamic parent-var)) ;; This prints 45!! (component thread variable!)
    (print (dynamic my-var))) ;; This prints 55
@end example    

@emph{An example of thread semantics:}

Queremos mostrar una lista y cada vez que hacemos click sobre uno de sus elementos, queremos abrir un editor en la parte de abajo de la pantalla:

@example
(defaction initialize ((comp main-component))
  (add-child comp 'elements
   (let ((list-component (make-instance 'collection-navigator :on *elements*)))
     (on-click list-component
	       (lambda (element)
		 (add-child comp 'element-editor
			    (with-transaction
				(call (make-instance 'element-editor :on element)))))))))
@end example                                

Entonces, cada vez que el usuario hace click en un elemento, se corre el thread para agregar el editor de elementos. Si hay un editor mostrandose, entonces se aborta el thread. La forma de abortar el thread es recuperando el contexto dinámico asociado a la continuación del thread y hacer un (signal 'abort-thread) (no se ejecuta la continuación) bajo ese contexto. En este ejemplo, se estaŕia ejecutando el unwind-protect de with-transaction. En otro caso, se podría interrumpir la cancelación del thread, y preguntar por la cancelación de la edición, por ejemplo así:

@example
(defaction initialize ((comp main-component))
  (add-child comp 'elements
   (let ((list-component (make-instance 'collection-navigator :on *elements*)))
     (on-click list-component
	       (lambda (element)
		 (add-child comp 'element-editor
			    (with-transaction
				(handler-case 
				    (call (make-instance 'element-editor :on element))
				  (abort-thread (e)
				    (when (call (make-instance 'message-box :text "Cancelar edición del elemento?"))
				      (signal e))))))))
     (call list-component)))) ;; re-signal the condition  ;; we do nothing other wise (the component remains in place)
@end example     

Problema: cómo tratar a with-transaction bajo extensión dinámica??: No queremos ejecutar with-transaction cada vez; queremos reutilizar la transacción bindeada en rucksack:*transaction*!! We should redefine it something like:

@example
(defmacro with-transaction% (&rest body)
  (with-gensyms (transaction)
    `(with-transaction
	 (let ((,transaction rucksack:*transaction*)) ; ,transaction should not be dynamically bound
	 (component-dynamic-wind
	  (let ((rucksack:*transaction* ,transaction))
	    (proceed ,@@body)))))))

(defmacro record-vars (vars &rest body)
  "Records dynamically bound variables in the compoenent dynamic-environment"
  (with-gensyms (proceed)
    (let ((gensyms (mapcar #'gensym vars)))
      `(let
	   ,(loop for var in vars
	       for gensym in gensyms
	       collect `(,gensym ,var))
	 (component-dynamic-wind ,proceed
         	 (let
		     ,(loop for var in vars
			 for gensym in gensyms
			 collect `(,var ,gensym)))
		 (,proceed ,@@body))))))

(defmacro with-dtransaction (&rest body)
  `(with-transaction
       (record-vars (rucksack::*transaction*)
		    ,@@body)))

(defmacro with-dactive-layers (&rest body)
  `(with-active-layers
       (record-vars (contextl::*active-context*)
		    ,@@body)))
@end example

@node Example - Programming a login
@subsubsection Example - Programming a login
@cindex login

Dynamic extent and user login:
------------------------------

If we have dynamic-extent reexecution semantics, then we can add a check for the logged user in the continuation, like this:

@example
(defaction start ((app my-app))
  (let (person)
    (block login
      (loop while t
	 when person do (return)
	 do (setf person (call (make-instance 'login-component)))))
    ;; We begin the session: these ones should be executed once only!! (shouldnt be part of the dynamic-environment)
    (proceed
     (begin-session)
     (set-logged-user person))
    ;; We make a dynamic check
    (if (current-session)
	(call 'main-component)
	;; else, we want the dialog to appear under the dynamic-extent
	(call-component 'message-dialog :text "You have to login to do that!"))))
@end example        

Maybe we should design our own operators to introduce dynamic-environments:

@example
(defmacro my-handler-case (expr cases)
  (with-gensyms (new-env proceed)
    `(with-dynamic-environment ((dynamic-environment (component)))
       (let ((,new-env
	      (dynamic-wind ,proceed
			    (handler-case
				(,proceed expr)
			      ,cases))))
	 (setf (dynamic-environment (component)) new-env)))))
@end example         

De esta forma, tenemos que todo se ejecuta una sola vez, solo determinadas partes. Además, deberíamos tener un component-dynamic-wind mejor:

@example
(defmacro component-dynamic-wind (&rest body)
  `(with-dynamic-environment ((dynamic-environment (component)))
     (let ((,new-env
	    (dynamic-wind ,@@body)))
       (setf (dynamic-environment (component)) new-env))))
@end example       

Y así nos queda:

@example
(defmacro dhandler-case (expr cases)
  (with-gensyms (proceed)
    `(component-dynamic-wind ,proceed
			     (handler-case
				 (,proceed expr)
			       ,cases))))
@end example                               

Y el login queda:

@example
(defaction start ((app my-app))
  (let (person)
    (loop while t
       when person do (return)
       do (setf person (call (make-instance 'login-component))))
    ;; We begin the session: these ones should be executed once only!! (shouldnt be part of the dynamic-environment)
    (begin-session)
    (set-logged-user person)
  ;; We make a dynamic check. This dynamic check affects all the components from the main-component ;)
    (component-dynamic-wind
     (if (current-session)
	 (proceed (call 'main-component))
	 ;; else, we want the dialog to appear under the dynamic-extent
	 (call 'message-dialog :text "You have to login to do that!")))))
@end example         

@node Component threads and database transactions
@subsubsection Component threads and database transactions
@cindex transactions, component threads and database
@cindex nested transactions

@emph{Nested component transactions semantics:}

If the inner transaction commits, then nothing happens. All the changes are commited iff the top level transaction commits.

If the inner transaction raises an error, or rollbacks, the outer transaction remains untouched. The inner transaction can be retried, and the computation resumes. That's why we have nested transactions; a nesting of transaction doesn't form a new bigger transaction, but the transactions hierarchy is preserved.

If the outer transaction rollbacks, then al changes are discarded, including changes made in inner transactions.

If the outer transaction commits, all the inner transactions must have been commited. If one of them is uncommited, then an error is raised (restart with the option to commit the remaining ones). If all of them are commited, then the outer transaction commits too, and all of the changes are made effective.
Once more, errors should be propagated through the component chain (not through the stack-chain).

@node Context Oriented Programming
@subsubsection Context Oriented Programming
@cindex cop
@cindex context oriented programming

Once dynamic language constructs are adapted, we can start to use context oriented features for our application.

Example:
@example
(deflayer listing-layer () ())

We can layer the controller behaviour:

(def-layered-component :layer listing-layer person-viewer (viewer))

(def-layered-method :layer listing-layer initialize ((viewer person-viewer))
		    ...)
@end example                    

After that we can do:

@example
(add-child
 (with-active-layers (listing-layer)
   (call (make-instance 'persons-component))))
@end example   

It is also possible, and may make sense, to make the template engine context aware:

@example
<template class="person-viewer"
          layer="listing-layer">
   ...
</template>
@end example

@node Layered components
@subsubsection Layered components

@node The view
@section The view
@cindex view

@menu
* View overview::              An overview of how the view is approached in Gestalt
* Defining a template::        The Gestalt template system overview
* Template assignation::       How templates get assigned to components
* Template elements::          Template elements
* Templates and scope::        Scope and template definitions
* Template combinations::      How templates can be combined
* Custom templates::           How to define your own class of templates
* Built-in templates classes:: Short reference of the already defined template classes
@end menu

@node View overview
@subsection View overview

     We achieve view-model-controller separation by means of templates. In spite of not begin of much use in some frameworks, I think they are indispensible for working with graphic designers.

    In Gestalt, templates are first-class XML entities. They are loaded in memory in your web application, and you can inspect them and modify them incrementally and on the fly.

@node Defining a template
@subsection Defining a template
@cindex templates

To define a template, we use the xml template element syntax:
@itemize
@emph{Syntax:}
@example
<template component-class="[component-class-name]"
          [qualifiers="@{qualifier@}*"] 
          [template-metaclass="template-metaclass-name"]
          [options="@{option@}*"]>
   @{xml-element@}*
</template>
@end example

@emph{Arguments and values:}
@itemize
@emph{component-class-name} -- The class name of the child component

@emph{qualifier} -- The template definition qualifiers. In a standard-template-combination, one of @emph{AROUND}, @emph{BELOW}, @emph{ABOVE}. This attribute is optional.

@emph{template-metaclass-name} -- The template metaclass. The template metaclass defines the way the templates qualifiers are interpreted and how the templates are attached to the component. Important restriction: all the templates defined for a particular class of component (you can have different definitions for the same class of component through templates qualifiers) must have the same template-metaclass. If this attribute is not specified, then the template-metaclass used is standard-template-metaclass. This attribute is optional.

@emph{options} -- The options are arbitrary strings consumed by the template-metaclass.
@end itemize
@end itemize

@emph{Description:}
The template xml element defines a template for a certain component class.

@emph{Examples:}
@example
<template class="person">
  <p>Name: </p> <container slot="name" 
                           class="label"/>
  <p> Lastname: </p> <container slot="lastname"
                                class="label"/>
</template>
@end example

@node Template assignation
@subsection Template assignation

@node Template elements
@subsection Template elements

@menu
* Container elements::         Embedding components in templates
* Container classes::          Container classes
* Design alternatives::        Design alternatives for container objects
* Collection elements::        Embedding a collection of elements
@end menu

@node Container elements
@subsubsection Container elements
@cindex container elements
Container elements refer to a model slot. The component slot is supposed to refer to a component or be null. If no component is begin referenced by the slot, then nothing is displayed. If the slot references a component, then a view is searched for it, attached to it, and displayed in the place the container element is found.
@subsubsection Container definition
@itemize
@emph{Syntax:}
@example
<container slot="[slot-name]" 
                 [class="container-class"]
       @{attributes@}*/>
@end example

@emph{Arguments and values:}
@itemize
@emph{slot-name} -- The name of the slots that contains the child component.

@emph{container-class-name} -- The name of the container-class.

@emph{attributes} -- A list of xml-attributes specifications that are used by the container-class.
@end itemize

@emph{Example}
@example
<template class="person">
   <container slot="name"/>
   <container slot="lastname"/>
   <container slot="friend"/>
</template>
@end example
@end itemize

@emph{Arguments and values:}

@node Container classes
@subsubsection Container classes
@cindex container classes
@itemize
@emph{Motivation}
When we use a container element to embed a component, the described algorithm is used to match the component view. But what we are trying to embed is a widget, things get a little too rigid. Let's take the following example to see this:
@example
<template class="person">
   <p>Name:</p><container slot="name"/>
   <p>Lastname:</p><container slot="lastname"/>
   <container slot="friend"/>
</template>
@end example
        In this example, we are saying we want the name and lastname of the person embedded, but we are not saying how. Let's suppose we have two Label wslotgets on them, as we are only interested in reading them, not writing the attributes. But we may want to represent that with a read-only text input instead of that. So we may use a container-class read-only-text-input to control that.
@example        
<template class="person">
   <p>Name:</p><container slot="name"
                          class="read-only-text-input"/>
   <p>Lastname:</p><container slot="lastname"
                              class="read-only-text-input"/>
   <container slot="friend"/>
</template>
@end example

@emph{Defining container classes:}
@itemize
@emph{Syntax:}
@example
@emph{- Macro:}
   define-container-class name (@{superclasses@}*)
      (@{slots@}*)
      (:compatiblity compatiblity-list)
      [(:render (view-type stream) @{form@}*)]
@end example

@emph{Arguments and values:}
@itemize
@emph{name} -- The name of the container class

@emph{superclasses} -- The classes the container class inherits from

@emph{slots} -- The list of the container class slots

@emph{compatibility-list} -- The list of the other container-classes this container-class is compatible with. 
@end itemize

@emph{Description:}
Defines a new container class.

@emph{Examples:}
@example
(define-container-class read-only-text-input (label)
     ()
     (:render (self stream (view-type (:eql 'html)))
                 (with-xml (stream)
                     (input :type "text"
                            :readonly t
                            :value (esc (print-string (model self))))))
             (:compatilibity-list '(label)))
@end example
In this case, the compatibility list indicates that a read-only-tet-input can be used in place of a label.
@end itemize
@end itemize

@node Design alternatives
@subsubsection Design alternatives

Maybe container elements are just too rigid. We can use a container-element mixin and a define-container-element macro and just use the name of the container element in the tag of the xml element.

Example:

@example
(define-container-element text-input ()
           )
@end example

And then:
@example
<template class="person">
   <p>Name:</p><text-input slot="name"
                           read-only="t"/>
   <p>Lastname:</p><container slot="lastname"
                              read-only="t"/>
   <container slot="friend"/>
</template>
@end example

instead of:

@example
<template class="person">
   <p>Name:</p><container slot="name"
                          class="read-only-text-input"/>
   <p>Lastname:</p><container slot="lastname"
                              class="read-only-text-input"/>
   <container slot="friend"/>
</template>
@end example

@node Collection elements
@subsubsection Collection elements
@cindex collection elements

Collection elements are a special kind of container elements. They are used to display collections of components.

@itemize
@emph{Syntax:}
@example
collection-element ::= <collection slot="slot-name"
                                [binding="binding-name"]>
                                @{template-definition@}*
                                @{xml-element | collection-element@}*
                       </collection>
collection-element ::= <collection-element [binding="binding-name"]/>
@end example

@emph{Arguments and values:}
@itemize
@emph{slot-name} -- The name of the slot that contains the collection of components.

@emph{binding-name} -- The name of the variable that binds the collection elements.

@emph{template-definition} -- A local template definition. Collection elements are scoped elements. That means you can define local templates in their bodies.
@end itemize

@emph{Description:}
Collection elements come in two flavors:

@itemize
@emph{Collection elements without body}
This is the easiest and more straightforward way of displaying a collection of elements. We display a collection of component; each component gets a view attached following the standard algorithm.
Example:
@example
<template class="person">
   <p>Name</p><text-input slot="name" style="read-only;"/>
   <p>Lastname</p><text-input slot="lastname" style="read-only;"/>
   <collection slot="friends"/>
</template>
@end example

@emph{Collection elements with body}
This flavor lets the user display the elements of a collection in a particual way. As a collection element is a scoped-element, we can define local templates in the beggining of its body.
Example: we can display a person's friends in a table like this:
@example
<template class="person">
            <p>Name</p><text-input slot="name" style="read-only;"/>
            <p>Lastname</p><text-input slot="lastname" style="read-only;"/>
            <table>
               <tbody>
         <collection slot="friends">
           <template class="person">
               Name: <label slot="name"/> lastname: <label slot="lastname"/>
           </template>
           <tr><collection-element/></tr>
         </collection>
               </tbody>
            </table>
          </template>
@end example

@emph{Collection bindings}
It may be desirable to give collection bindings a name instead of doing it implitly by the standard form of collection-element xml element. This is true in situations we we want to nest two collections of elements. In that case, we can use the 'binding' attribute.
Example:
@example
          <collection slot="friends" binding="friend">
             <collection slot="friend-friend">
           <tr>
             <td><collection-element binding="friend"/>
                 <collection-element binding="friend-friend"/>
             </td>
           </tr>
             </collection>
          </collection>
@end example
@end itemize
@end itemize

@node Templates and scope
@subsection Templates and scope
@cindex scope, templates and
    Some templates elements introduce new scopes. That means we can declare templates that are relevant in the scope of that element only. The most common examples of those elements are template and collection. Those elements may have a list of template definitions in the beggining of their body, before any other type of xml element.

Examples:
@example
    <template class="person">
      <template class="person">
         <p>Friend name:</p><label slot="name"/>
         <p>Friend lastname:</p><label slot="lastname"/>
      </template>
      <p>Name:<p><label slot="name"/>
      <p>Lastname:</p><label slot="lastname"/>
      <container slot="friend"/>
    </template>
    
    <template class="person">
         <p>Name</p><text-input slot="name" style="read-only;"/>
         <p>Lastname</p><text-input slot="lastname" style="read-only;"/>
         <table>
            <tbody>
              <collection slot="friends">
                <template class="person">
                    Name: <label slot="name"/> lastname: <label slot="lastname"/>
                </template>
                <tr><collection-element/></tr>
              </collection>
            </tbody>
         </table>
       </template>
@end example

Implementation: XML elements that introduce new scopes are inherited from the scoping-template-element class. You can inherit from it when defining your own template elements.

@node Template combinations
@subsection Template combinations
@cindex combinations, template

@menu
* Template combinations overview::         A brief summary of what template combinations are
* Standard template combination::          The standard template combination
@end menu

@node Template combinations overview
@subsubsection Template combinations overview

In order to improve templates composition we provide template combinations. Template combinations are a lot like Common Lisp method combinations and are inspired by them, but for templates. The default template combination in standard-template-combination.
    
    Template combinations use the qualifiers of the template definition for instantiating the view to the component.

@node Standard template combination
@subsubsection Standard template combination
@cindex standard template combination
    The standard template combination recognizes AROUND, ABOVE  and BELOW qualifiers, corresponding to AROUND, BEFORE and AFTER of standard method combination.

@itemize
@emph{AROUND combination}
      AROUND templates are displayed around the ABOVE, PRIMARY and BELOW templates. Templates embedding is achieved through the element <next-template/>
      Example:
      @example
        <template component-class="person"
           qualifiers="around">
            <div style="background-color:red;">
        <next-template/>
            </div>
        </template>
      @end example  
      This makes the person to be displayed inside a red coloured box.

@emph{ABOVE combination}
ABOVE templates are displayed above the PRIMARY template.
   Example:
   @example
        <template class="person"
           qualifiers="above">
            <p>There's a person below this message</p>
        </template>
   @end example

@emph{BELOW combination}
  BELOW templates are displayed below the PRIMARY template
  Example:
  @example
        <template class="person"
           qualifiers="below">
            <p>There's a person above this message</p>
        </template>
  @end example      
@end itemize


@node Custom templates
@subsection Custom templates
@cindex custom templates

It is possible to define custom templates through a MOP.

The algorithm to change the way views are assigned to component can be changed creating a new template-metaclass, assigning a new template-combintation to it and defining the appropiate methods. For an example of this, see [Context oriented templates].

@node Built-in templates classes
@subsection Built-in templates classes
@cindex built-in template classes

+ Standard templates 
    standard-template-class
+ Context oriented templates 
    cop-template-class

@node Third-party libraries
@chapter Third-party libraries
@menu
* Elephant::               The elephant object database
* First-class URLs::       Library that provides first-class URLs management
* Consistent object library::     consistent-object library reference
* Dataflow::               Dataflow library reference
* Utilities::              Utilities library (copying objects, doubly-linked 
@end menu

@node Elephant
@section Elephant
@cindex elephant
Embed or link elephant database doc here...

@node First-class URLs
@section First-class URLs
@cindex url

The problem:
------------

Some of the problems I see repeatedly in this and other Web frameworks is the URLs handling. URLs are generally represented as simple strings. That is inconvinient in my opinion. When treating them as strings, concatenating them becomes an issue, specially because of the #\\ character. Besides, matching the action corresponding to the URL it too coupled to how the URL strings are. That makes Web applications configuration and deployment more difficult than it should be.


Proposal:
---------
I propose treating URL as first-class entities, a lot like what CL-FAD http://www.cliki.net/CL-FAD does with pathnames.


Implementation sketch:
----------------------

(help me with the names, I'm not very good at English!)

We can represent URLs with CLOS objects:

@example
(defmacro generic-url (url)
  ((protocol :initarg :protocol
	     :accessor protocol)
   (hostname :initarg :hostname
	     :accessor hostname)
   (path :initarg :hostname
	 :accessor hostname)
   (program :initarg :program
	    :accessor program)
   (parameters :initarg :parameters
	       :accessor parameters
	       :documentation "Property list from ?a1=v1&a2=v2&...&an=vn")
   (fragment :initarg :fragment
	     :accessor fragment))
  (:documentation "A typical URL. Example: protocol://hostname:port/path/program?a1=v1&a2=v2&...&an=vn#fragment"))

(defun concatenate-urls (&rest urls)
  "URLs concatenation (corrent handling of the #\\ character)")

(defun read-url (str)
  "Create a url from a string (used by reader-syntax)")
@end example  

We can also define some protocols:

@example
(defvar *url-protocols*
  (make-hash-table :test #'equal))

(defmacro define-url-protocol (name &optional (str `(symbol-name ',name)))
  `(setf (gethash ',name *url-protocols*) ,str))

(define-url-protocol :http)
(define-url-protocol :ftp)
@end example

And finally provide some reader syntax:

@example
#url"http://localhost/myapp/main.do"
@end example

@node Consistent object library
@section Consistent object library
@cindex consistent object

@node Dataflow
@section Dataflow
@cindex dataflow

@node Utilities
@section Utilities
@cindex utilities

@node Standard applications
@chapter Standard applications
@cindex standard applications

@menu
* Application login::         How to program the application login?
* Access control::            How to do permission checking
* Standard widgets::          The standard widgets
* Objects meta editors::      Generating objects editors reflectively
@end menu

@node Application login
@section Application login
@cindex login

@node Access control
@section Access control
@cindex access control

@example
(add-component 'button (make-instance 'button :action #'some-action)
     :when (let ((model (model self)))
              (df
                 (can-do-some-action model))))
@end example

In this case, the @emph{model} library in the @emph{df} form is free, so it is assumed to be a dataflow variable: whenever the model changes the @emph{can-do-some-action} condition is rechecked  and the component is enabled or disabled accordingly.

@node Standard widgets
@section Standard widgets
@cindex widgets

@node Objects meta editors
@section Objects meta editors
@cindex meta editors

@node Tools
@chapter Tools
@cindex tools
@menu
* Configuration::             How to configure a Gestalt application
* Debugging::                 How to debug Gestalt applications
* Inspector::                 The web inspector
* Profiling::                 How to profile Gestalt applications
* Deployment::                How to deploy a Gestalt application
@end menu

@node Configuration
@section Configuration
@cindex configuration

@node Debugging
@section Debugging
@cindex debugging

@node Inspector
@section Inspector
@cindex inspector

@node Profiling
@section Profiling
@cindex profiling

@node Deployment
@section Deployment
@cindex deployment

@node System reference
@chapter System reference

@node References
@chapter References
@cindex reference

 [Common Lisp Directory]
  
  [Smalltalk Seaside Web Framework]

  [Common Lisp Wiki]

  [Cells - A Common Lisp dataflow extension]

  [[http://common-lisp.net/project/elephant][Elephant - A Common Lisp object database]

  [Common Lisp Directory]: http://common-lisp.net
  [Smalltalk Seaside Web Framework]: http://seaside.st
  [Common Lisp Wiki]: http://www.cliki.net
  [Cells - A Common Lisp dataflow extension]: http://common-lisp.net/project/cells

@node Appendix
@chapter Appendix
@cindex appendix

This is the appendix...

@node Index
@unnumbered Index

@printindex cp

@bye
