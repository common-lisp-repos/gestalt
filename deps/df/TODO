Value models and our dataflow extension
---------------------------------------

We need at least two different macros. One that creates a value-cell (value-holder) from syntax.
Another that creates a aspect-cell (aspect-adaptor) from syntax.

Value holders:
-------------

The first:

(df (:value)      ; note the :value keyword
     (let*	
	 ((value 44)
	  (suma (+ slot value)))
       (format t "Getting value of suma2!!~%")
       (* suma value)))

 Should generate:
 (make-instance 'value-cell
    ...)
    


Aspect adaptors: (Adapts on an object method)
-------------

So we need to generate appropiate dataflow-cell's.


(df (:aspect)
  (name person))
  
Should generate:

(make-cell :setter (lambda (arg) (setf (name person) arg))
           :getter (lambda () (name person)))

And we need (setf name) ((p person) value) to be defined. It throws an error otherwise.

(df
     (let*	
	 ((value 44)
	  (suma (+ slot value)))
       (format t "Getting value of suma2!!~%")
       (* suma value)))

Other cases:
-----------

We can treat other cases explicetly (no macro syntax support). For example, we can build our own aspect cells explicetly
providing the setter and getter lambdas.


General refactoring:
-------------------

Nota: en este momento el algoritmo de dataflow se encuentra
en los wlambda creados. Para desacoplar el algoritmo habria que transformar el codigo de forma tal de crear lambdas que bindeen con nuevas variables todas las variables libres. Además, cada celda debería contener una tabla weak a las variables libres. Para ejecutar, habria que pasar esas variables al nuevo lambda generado.

Implementation sketch:

Example:

(let
   ((x (make-instance 'value-cell :value 23))
    (y (make-instance 'formula-cell
                       :arguments x
		       :formula (lambda (x) (+ 3 x)))))
		       ...)

(defmethod initialize-instance :after ((cell formula-cell) &rest initargs)
   ;; Keep weak-references to the bindings only
   (setf (arguments cell)
       (for arg in (arguments cell)
            collect (make-weak-pointer arg))
	    do (add-dependent cell arg :changed))) ;; register as a dependent of the argument
	    
(defmethod evaluate ((cell formula-cell))
    "cell evaluation
    use the values of the weakly bound arguments. if one of them is not bound, returns nil
    returns 2 values: the evaluated value, and T or NIL if the cell could be evaluated or not"
    (let ((args (loop for arg in (arguments cell)
                      for c = (weak-pointer-value arg)
		      when (null c) do (return-from evaluate (values nil nil))
		      collect (value c))))
        (values (apply (formula cell) args)
		t)))

(defmethod propagate (event cell)
   (loop for dependent in (dependents-on :changed cell)
         do (multiple-value-bind (value evaluated-p) (evaluate dependent)
	      (if evaluated-p
	          (propagate event dependent)))))

Updating suspensions:
--------------------

(suspending-subscriptions (:subs :all) my-cell
   (do-something))

(suspending-subscriptions (:subs subscriber1 subscriber2) my-cell
   (do-something))

(suspending-subscriptions (:event :changed) my-cell
   (do-something))